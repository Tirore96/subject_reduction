This artifact accompanies the paper titled Multiparty Asynchronous Session Types: A Mechanised Proof of Subject Reduction. It consists of a Coq (version 8.15.0) mechanisation of the subject reduction theorem and communication safety for multiparty asynchronous session types.

# FYI about multiple branches in the repo

The artifact on branch (main) accompanies the version of the paper that appears in my PhD [thesis](https://tirore96.github.io/assets/thesis.pdf). The main result is a Coq proof of subject reduction for multiparty session types. The artifact on the branch (ECOOP2025) contains the latest version of the artifact, and accompanies a newer version of the paper which has been accepted for publication at ECOOP2025. The latest version builds on the subject reduction result and also shows communication safety.

# Installing from scratch

  This section provides installation instructions without the use of a docker image.

  Make sure opam version is 2.1.0 or above (`opam --version`).
  
  If `opam` has not been used before, it must be initialised
  
  ```
  opam init
  eval $(opam env)
  ```
  
  Next run the following commands from the `subject_reduction/` directory
   
  ```
  opam switch create ARTIFACT 4.10.2
  eval $(opam env --switch=ARTIFACT)
  opam pin add coq 8.15.0
  opam repo add coq-released https://coq.inria.fr/opam/released
  opam install coq-mathcomp-ssreflect.1.17.0
  opam install coq-paco.4.2.0
  opam install coq-mathcomp-zify.1.3.0+1.12+8.13
  opam install coq-deriving.0.1.1
  opam install coq-equations.1.3+8.15
  coq_makefile -f _CoqProject -o CoqMakeFile
  make -f CoqMakeFile
  ```
You can go back to your own switch with `eval $(opam env --switch=NAMEOFYOURSWITCH)`

## Expected output
The last part of `SubjectRed4.v` is three print statements 
```
 Print Assumptions OFT_cong.
 Print Assumptions subject_reduction_final.
 Print Assumptions subject_reduction_empty.
 Print Assumptions OFT_not_error_struct.
``` 
They print the additional axioms (besides standard CIC axioms) that our Subject Reduction theorem (Theorem 26 in the paper) relies on. Common for all three statements in the theorem, is that they rely only on functional extensionality, which is printed four times.

To compile the proofs, run the command `make -f CoqMakefile` in the root of the directory. The expected output is:
```
....
COQC theories/Process/SubjectRed.v
COQC theories/Process/linearity_equiv.v
COQC theories/Process/SubjectRed2.v
COQC theories/Process/SubjectRed3.v
COQC theories/Process/SubjectRed4.v
COQC theories/Process/Safety.v
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
```
To remove the additional files generated by compilation, run the command `make -f CoqMakeFile clean` in the root of the directory.

# Mapping definitions:

This is a comprehensive list of all the main definitions and theorems from the paper. All these theorems are also directly linked to the online repository (https://github.com/Tirore96/subject_reduction/tree/ECOOP2025/theories) via the rooster icon in the paper. The root is the `theories` folder.

* Section 2
    * Process syntax: `Process/processSyntax.v` as `process`
    * Congruence: `Process/Congruence.v` as `Cong`
    * Reduction: `Process/SubjectRed.v` as `Sem`
* Section 3
    * Syntax: `IndTypes/syntax.v` where global types are defined as `gType` and local types as `lType` (Note we only have message type bool, and the message type int used in the paper is there to illustrate examples)
    * Projection: Projection of Tirore et al. Their projection implementation is contained in 
       Projection/*`, `IndTypes/*` and `CoTypes/*` and the procedure is `proj` in `Projection/indProj.v`
    * Semantics
        * Global types: `linearity.v` where the relation is `step`
        * Local types and environments: `harmony.v` where the relations are `Estep` and `EnvStep`
    * Linearity
        * Trace: `linearity.v` as `Tr`
        * Input/output dependence: `linearity.v` as `exists_dep InDep` and `exists_dep OutDep`. The paper presentation of dependence has been simplified. In `Process/linearity_equiv.v` we prove this definition equivalent to the coinductive formulation of linearity
        * Coinductive linearity definition: `linearDecide.v` as `LinearCo`
        * Decidability of Linearity: `linearDecide.v` where the lemma is `Linear_decidable`
    * Projection Theorem
        * Coinductive Equality: `CoTypes/coLocal.v` where the relation is `EQ2`
        * Decidability of Coinductive Equality: `CoTypes/bisim.v` as `bisim'`
        * The theorem: `harmony.v` (->) as `harmony_sound` and (<-) as `harmony_complete`
* Section 4
    * Queue types and queue contexts
        * Queue type and environment: `Congruence.v` as `qType` and `q_env`
        * Decomposition: `Congruence.v` as `split_set`
    * Coherence
        * Unstuck: Auxiliary step predicate for unstuckness in `Process/Congruence.v` as the predicate `canStep`. The full unstuck predicate as `goodG`.
        * Coherence definition: `Process/Congruence.v` where coherence of global types is `coherentG`, coherence of projected global types is `coherent`. `Process/SubjectRed4.v` where decomposed local type environment is coherent as `weak_coherent_as`
* Section 5
    * Typing judgment: `Process/Congruence.v` as `OFT`
    * Partitioning:  `Process/Congruence.v`, as the function `filter_q` which splits the typing environment for queues `q_env`
    * Typing of declarations: `Process/Congruence.v` as `DefTyping`
    * Substitution lemma: `Process/Congruence.v` as `OFT_subst`
    * Example typing of process using declarations:
      `Process/Example.v` as `typing`
    * Subject Congruence and Reduction: (1) in `Process/Congruence.v`
      as `OFT_cong`, (2) and (3) in `Process/SubjectRed4.v` as
      `subject_reduction_final` and `subject_reduction_empty`
    * Definition of error, Communication Safety theorem and corollary:
      `Process/Safety.v` as `Error_struct`, `OFT_not_error_struct` and
      `OFT_not_error_sem`
