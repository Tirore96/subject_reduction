This artifact accompanies the paper titled Multiparty Asynchronous Session Types: A Mechanised Proof of Subject Reduction. It consists of a Coq (version 8.15.0) mechanisation of the subject reduction theorem and communication safety for multiparty asynchronous session types.

# Compiling with docker

For the artifact reviewers of ECOOP 2025, a Docker image containing the Coq code and its dependencies has been made available.

To spin up a container based on this image run 
```docker container -it <image>```

This opens an interactive shell inside the container

Now navigate to the subject_reduction folder by running
```cd <path>```


The Coq code can now be compiled by running
```make -f CoqMakefile```

For the expected output please see the section "Expected output" below in this README.


# Installing from scratch

  This section provides installation instructions without the use of a docker image.

  Make sure opam version is 2.1.0 or above (`opam --version`).
  
  If `opam` has not been used before, it must be initialised
  
  ```
  opam init
  eval $(opam env)
  ```
  
  Next run the following commands from the `subject_reduction/` directory
   
  ```
  opam switch create ARTIFACT 4.10.2
  eval $(opam env --switch=ARTIFACT)
  opam pin add coq 8.15.0
  opam repo add coq-released https://coq.inria.fr/opam/released
  opam install coq-mathcomp-ssreflect.1.17.0
  opam install coq-paco.4.2.0
  opam install coq-mathcomp-zify.1.3.0+1.12+8.13
  opam install coq-deriving.0.1.1
  opam install coq-equations.1.3+8.15
  ```
You can go back to your own switch with `eval $(opam env --switch=NAMEOFYOURSWITCH)`

Finally, you have to move the root folder of the subject_reduction repository into the container. You do this in a separate terminal window (the other being used for the container). 

First clone the repo url

```
git clone git@github.com:Tirore96/subject_reduction.git
```

After cloning the repo and checking out ECOOP2025, run

```
docker container cp subject_reduction/ myContainer:/home/coq/.
```

and go back to the terminal window used by the container. Now, change the ownership of the copied folder and move to it: 

```
sudo chown -R coq subject_reduction/
cd subject_reduction/
```

Finally, create the makefile and run make: 

```
coq_makefile -f _CoqProject -o CoqMakeFile
make -f CoqMakeFile
```




## Expected output
The last part of `SubjectRed4.v` is three print statements 
```
 Print Assumptions OFT_cong.
 Print Assumptions subject_reduction_final.
 Print Assumptions subject_reduction_empty.
``` 
They print the additional axioms (besides standard CIC axioms) that our Subject Reduction theorem (Theorem 26 in the paper) relies on. Common for all three statements in the theorem, is that they rely only on functional extensionality, which is printed three times.

To compile the proofs, run the command `make -f CoqMakefile` in the root of the directory. The expected output is:
```
....
COQC theories/Process/SubjectRed.v
COQC theories/Process/linearity_equiv.v
COQC theories/Process/SubjectRed2.v
COQC theories/Process/SubjectRed3.v
COQC theories/Process/SubjectRed4.v
COQC theories/Process/Safety.v
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Axioms:
FunctionalExtensionality.functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
```
To remove the additional files generated by compilation, run the command `make -f CoqMakefile clean` in the root of the directory.

# Mapping definitions:

This is a comprehensive list of all the main definitions and theorems from the paper. All these theorems are also directly linked to the online repository (https://github.com/Tirore96/subject_reduction/tree/ECOOP2025/theories) via the rooster icon in the paper. The root is the `theories` folder.

* Section 2
    * Process syntax: `Process/processSyntax.v` as `process`
    * Congruence: `Process/Congruence.v` as `Cong`
    * Reduction: `Process/SubjectRed.v` as `Sem`
* Section 3
    * Syntax: `IndTypes/syntax.v` where global types are defined as `gType` and local types as `lType` (Note we only have message type bool, and the message type int used in the paper is there to illustrate examples)
    * Projection: Projection of Tirore et al. Their projection implementation is contained in 
       Projection/*`, `IndTypes/*` and `CoTypes/*` and the procedure is `proj` in `Projection/indProj.v`
    * Semantics
        * Global types: `linearity.v` where the relation is `step`
        * Local types and environments: `harmony.v` where the relations are `Estep` and `EnvStep`
    * Linearity
        * Trace: `linearity.v` as `Tr`
        * Input/output dependence: `linearity.v` as `exists_dep InDep` and `exists_dep OutDep`. The paper presentation of dependence has been simplified. In `Process/linearity_equiv.v` we prove this definition equivalent to the coinductive formulation of linearity
        * Coinductive linearity definition: `linearDecide.v` as `LinearCo`
        * Decidability of Linearity: `linearDecide.v` where the lemma is `Linear_decidable`
    * Projection Theorem
        * Coinductive Equality: `CoTypes/coLocal.v` where the relation is `EQ2`
        * Decidability of Coinductive Equality: `CoTypes/bisim.v` as `bisim'`
        * The theorem: `harmony.v` (->) as `harmony_sound` and (<-) as `harmony_complete`
* Section 4
    * Queue types and queue contexts
        * Queue type and environment: `Congruence.v` as `qType` and `q_env`
        * Decomposition: `Congruence.v` as `split_set`
    * Coherence
        * Unstuck: Auxiliary step predicate for unstuckness in `Process/Congruence.v` as the predicate `canStep`. The full unstuck predicate as `goodG`.
        * Coherence definition: `Process/Congruence.v` where coherence of global types is `coherentG`, coherence of projected global types is `coherent`. `Process/SubjectRed4.v` where decomposed local type environment is coherent as `weak_coherent_as`
* Section 5
    * Typing judgment: `Process/Congruence.v` as `OFT`
    * Partitioning:  `Process/Congruence.v`, as the function `filter_q` which splits the typing environment for queues `q_env`
    * Typing of declarations: `Process/Congruence.v` as `DefTyping`
    * Substitution lemma: `Process/Congruence.v` as `OFT_subst`
    * Example typing of process using declarations:
      `Process/Example.v` as `typing`
    * Subject Congruence and Reduction: (1) in `Process/Congruence.v`
      as `OFT_cong`, (2) and (3) in `Process/SubjectRed4.v` as
      `subject_reduction_final` and `subject_reduction_empty`
    * Definition of error, Communication Safety theorem and corollary:
      `Process/Safety.v` as `Error_struct`, `OFT_not_error_struct` and
      `OFT_not_error_sem`
